ğŸ§© What prototypal inheritance really is

In JavaScript, every object has a hidden link called [[Prototype]] (or accessible via __proto__) to another object â€” its prototype.

When you access a property on an object, JS walks up this chain:

object â†’ prototype â†’ prototype â†’ ... â†’ Object.prototype

So inheritance in JS isnâ€™t about â€œcopyingâ€ properties from parent to child â€” itâ€™s about sharing behavior through delegation.

â¸»

âš™ï¸ Why it exists â€” the real benefit

The main purpose of prototypes is to share methods and behavior efficiently between many instances.

If you create 1 million User objects, each shouldnâ€™t have its own copy of methods like login() or logout().
You put those methods on the prototype so theyâ€™re shared, not duplicated.

â¸»

ğŸ’¡ Example: Where we actually use it

1. Reusing shared methods efficiently

function User(name) {
  this.name = name;
}

// Shared behavior â€” only one copy exists
User.prototype.greet = function() {
  console.log(`Hi, I'm ${this.name}`);
};

const u1 = new User("Shash");
const u2 = new User("Aman");

u1.greet(); // "Hi, I'm Shash"
u2.greet(); // "Hi, I'm Aman"

// Memory-efficient â€” only one 'greet' function lives in memory

If greet was defined inside the constructor, every new User would get its own copy, wasting memory.

â¸»

2. Extending built-in objects

You can extend the functionality of existing JS objects (though you usually avoid modifying built-ins directly in production).

Array.prototype.last = function() {
  return this[this.length - 1];
};

console.log([1,2,3].last()); // 3

Thatâ€™s prototype inheritance â€” all arrays now â€œinheritâ€ that new last() method.

â¸»

3. Creating hierarchies (class-like inheritance)

Before ES6 classes existed, prototypes were how we simulated â€œOOP-styleâ€ inheritance:

function Animal(name) {
  this.name = name;
}
Animal.prototype.eat = function() {
  console.log(`${this.name} is eating`);
};

function Dog(name, breed) {
  Animal.call(this, name); // inherit properties
  this.breed = breed;
}

Object.setPrototypeOf(Dog.prototype, Animal.prototype);

Dog.prototype.bark = function() {
  console.log(`${this.name} barks`);
};

const rex = new Dog("Rex", "German Shepherd");
rex.eat();  // inherited from Animal
rex.bark(); // defined on Dog

Thatâ€™s prototypal inheritance in action â€” Dog delegates to Animal, no method copies involved.

â¸»

4. Prototypal pattern (direct object inheritance)

You can also skip â€œclassesâ€ entirely and just use plain objects that inherit from other objects:

const animal = {
  eat() { console.log(`${this.name} eats.`); }
};

const dog = Object.create(animal);
dog.name = "Rex";
dog.bark = function() { console.log(`${this.name} barks.`); };

dog.eat();  // from prototype
dog.bark(); // from itself

âœ… Simple, elegant, and used in frameworks (like Reactâ€™s early internal patterns, pre-hooks).

â¸»

ğŸ”§ Real-World Scenarios You See Prototypes In

Scenario	Description
Browser APIs	DOM objects (e.g. HTMLElement, Node, EventTarget) use deep prototype chains.
Custom Libraries/Frameworks	Object-based inheritance in older JS frameworks (AngularJS, Backbone).
Performance Optimization	Sharing behavior across thousands of similar objects.
Polyfills / Patches	Adding methods to built-ins via their prototypes (e.g., Array.prototype.includes).
Class Syntax (under the hood)	ES6 class is syntactic sugar over prototypes â€” still uses them internally.


â¸»

ğŸ§  Mental Model

Think of the prototype as a blueprint of shared behavior.
Instances just have their own data, and they delegate behavior lookup to their prototype.

Instance (data) ----> Prototype (shared methods)


â¸»

ğŸ”¥ TL;DR â€” Why prototypes matter

âœ… Efficiency: one copy of shared behavior
âœ… Extensibility: easy to chain and override
âœ… Foundation: everything in JS (including classes) is built on it
âŒ Not for data: use them for behavior, not unique properties

